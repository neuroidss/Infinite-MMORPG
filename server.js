// server.js - Backend Logic
// @ts-check

import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';
import { v4 as uuidv4 } from 'uuid';
import fetch from 'node-fetch'; // For Ollama API calls

// --- Configuration ---
const HOSTNAME = process.env.HOSTNAME || '0.0.0.0';
const PORT = process.env.PORT || 3000;
const DEBUG = process.env.DEBUG === 'true' || true; // Enable debug mode by default for easy testing
const DESIRED_BOTS = 10;
const HEALTH_AND_ATTACK_MULTIPLIER = 1;
const BOT_SPEED_MULTIPLIER = 4;
const TICK_RATE = 30; // Game loop updates per second
const OLLAMA_API_URL = process.env.OLLAMA_API_URL || 'http://10.8.0.14:11434/v1/chat/completions'; // OpenAI compatible endpoint
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'qwen2.5-coder:7b-instruct-q8_0'; // Make sure this model is running in Ollama
const VERSION = "1.0.0"; // Simple versioning
const GACHA_INTERVAL_MS = 60 * 1000; // 1 minute
const ARTIFACT_DESPAWN_TIME_MS = 30 * 1000; // 30 seconds on ground
const DUNGEON_CLOSE_DELAY_MS = 20 * 1000; // 20 seconds after boss defeat
const PLAYER_REACH = 2.5;
const MOB_REACH = 2.0;
const ARENA_SIZE = 10; // Half-size of the arena square centered at 0,0 // 50
const MAX_CHATBOT_CALLS_SIMULTANEOUSLY = 1; // For debug/control

// --- Helper Functions ---
const log = (...args) => DEBUG && console.log('[SERVER]', ...args);
const calculateDistance = (pos1, pos2) => Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.z - pos2.z, 2));
const getRandomPosition = (y = 0.5) => ({
    x: (Math.random() - 0.5) * ARENA_SIZE * 1.8, // Slightly outside initial view for spawning
    y: y,
    z: (Math.random() - 0.5) * ARENA_SIZE * 1.8
});
const clampToArena = (position) => {
    position.x = Math.max(-ARENA_SIZE, Math.min(ARENA_SIZE, position.x));
    position.z = Math.max(-ARENA_SIZE, Math.min(ARENA_SIZE, position.z));
    // y is usually height, don't clamp unless needed
};

// --- Game State ---
let deltaTime;
let players = {};
let mobs = {};
let artifacts = {}; // Instantiated artifacts in the world (on ground)
let dungeons = {}; // Active dungeons
let knownArtifactTemplates = {}; // Templates generated by chatbot
let knownMobTemplates = {}; // Templates generated by chatbot
let knownElements = { // Initial elements
    pyro: { name: 'pyro', color: 0xff4500 },
    hydro: { name: 'hydro', color: 0x1e90ff },
    electro: { name: 'electro', color: 0x9400d3 },
    cryo: { name: 'cryo', color: 0xadd8e6 },
    dendro: { name: 'dendro', color: 0x228b22 },
    anemo: { name: 'anemo', color: 0x7fffd4 },
    geo: { name: 'geo', color: 0xdaa520 },
    physical: { name: 'physical', color: 0xaaaaaa } // Default
};
let elementReactions = { // TargetElement: { AttackingElement: ReactionFunction }
    // Simplified reactions for now - apply extra damage or status
    _default: (target, attacker, attackingElement) => { log(`Reaction: ${attackingElement.name} hit ${target.element?.name || 'none'}`); return 1; }, // Generic handler // 0
    _applyStatus: (target, status, duration = 5000) => {
        target.statusEffects = target.statusEffects || {};
        const existing = target.statusEffects[status.name];
        if (!existing || Date.now() > existing.expires) {
            target.statusEffects[status.name] = { applied: Date.now(), expires: Date.now() + duration, ...status };
            log(`Applied status ${status.name} to ${target.id}`);
        }
    },
    pyro: {
        hydro: (t, a, e) => { log('Vaporize!'); return 1.5; }, // Multiplier
        electro: (t, a, e) => { log('Overload!'); return 1.2; },
        cryo: (t, a, e) => { log('Melt!'); return 2.0; },
        anemo: (t, a, e) => { log('Swirl (Pyro)!'); return 1.1; }, // Swirl might spread element later
        geo: (t, a, e) => { log('Crystallize (Pyro)!'); return 1.0; }, // Crystallize might create shield later
    },
    hydro: {
        electro: (t, a, e) => { log('Electro-Charged!'); elementReactions._applyStatus(t, { name: 'electro-charged', dps: 5, interval: 1000 }, 5000); return 1.1; },
        cryo: (t, a, e) => { log('Frozen!'); elementReactions._applyStatus(t, { name: 'frozen', immobilize: true }, 3000); return 1.0; },
        dendro: (t, a, e) => { log('Bloom!'); /* Spawn bloom core later */ return 1.0; },
        anemo: (t, a, e) => { log('Swirl (Hydro)!'); return 1.1; },
        geo: (t, a, e) => { log('Crystallize (Hydro)!'); return 1.0; },
    },
    electro: {
        cryo: (t, a, e) => { log('Superconduct!'); return 1.2; /* Reduce phys res later */ },
        dendro: (t, a, e) => { log('Quicken!'); elementReactions._applyStatus(t, { name: 'quicken' }, 10000); return 1.0; },
        // Aggravate/Spread handled separately based on quicken status
        anemo: (t, a, e) => { log('Swirl (Electro)!'); return 1.1; },
        geo: (t, a, e) => { log('Crystallize (Electro)!'); return 1.0; },
    },
    cryo: {
        anemo: (t, a, e) => { log('Swirl (Cryo)!'); return 1.1; },
        geo: (t, a, e) => { log('Crystallize (Cryo)!'); return 1.0; },
    },
    dendro: {
        pyro: (t, a, e) => { log('Burning!'); elementReactions._applyStatus(t, { name: 'burning', dps: 8, interval: 500 }, 6000); return 1.0; },
        // Burgeon/Hyperbloom need bloom cores
        anemo: (t, a, e) => { log('Swirl (Dendro)!'); return 1.1; },
        geo: (t, a, e) => { log('Crystallize (Dendro)!'); return 1.0; },
    },
    // Special cases for quicken
    quicken: {
        electro: (t, a, e) => { log('Aggravate!'); return 1.3; },
        dendro: (t, a, e) => { log('Spread!'); return 1.3; },
    }
};

let chatbotState = {
    isBusy: false,
    activeCalls: 0,
    lastDungeonCreation: Date.now(),
    lastSenseTime: Date.now(),
    senseInterval: 60 * 1000, // Check world state every minute
    dungeonTriggerInterval: 5 * 60 * 1000, // Try to make a dungeon every 5 mins if needed
};

// --- Server Setup ---
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Serve version info
app.get('/version', (req, res) => {
    res.json({ version: VERSION });
});

// Serve latest frontend
app.get('/client.js', (req, res) => {
    // In a real scenario, you might read index.html and extract the script block
    // For simplicity here, we assume index.html is static or handled differently.
    // This endpoint is more for a scenario where JS is a separate file.
    // Given the single-block requirement, this might not be strictly needed
    // unless we modify index.html to fetch its JS. Let's serve index.html itself.
    res.sendFile(path.join(__dirname, 'index.html'));
});

// --- Ollama Interaction ---
const callOllamaAPI = async (messages, tools) => {
    if (chatbotState.activeCalls >= MAX_CHATBOT_CALLS_SIMULTANEOUSLY) {
        log("Chatbot busy, skipping API call.");
        return null; // Skip if already busy
    }
    chatbotState.activeCalls++;
    chatbotState.isBusy = true;
    log(`Calling Ollama (${OLLAMA_MODEL}) with ${messages.length} messages. Tools: ${tools ? tools.map(t => t.function.name).join(', ') : 'None'}`);

    const body = {
        model: OLLAMA_MODEL,
        messages: messages,
        stream: false, // We want the full response including tool calls
    };
    if (tools && tools.length > 0) {
        body.tools = tools;
        body.tool_choice = "auto";
    }

    try {
        const response = await fetch(OLLAMA_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        if (!response.ok) {
            throw new Error(`Ollama API error: ${response.status} ${response.statusText} - ${await response.text()}`);
        }

        const data = await response.json();
        log("Ollama response received:", JSON.stringify(data).substring(0, 200) + "..."); // Log truncated response

        // Check for tool calls in the response message
        if (data.choices && data.choices[0].message && data.choices[0].message.tool_calls) {
            log(`Ollama responded with ${data.choices[0].message.tool_calls.length} tool calls.`);
            return data.choices[0].message.tool_calls; // Return only the tool calls array
        } else {
            log("Ollama response did not contain tool calls.");
            if (data.choices && data.choices[0].message && data.choices[0].message.content) {
                log("Ollama content response:", data.choices[0].message.content);
            }
            return null; // Indicate no tool calls were made
        }
    } catch (error) {
        console.error("Error calling Ollama API:", error);
        return null; // Indicate failure
    } finally {
        chatbotState.activeCalls--;
        chatbotState.isBusy = chatbotState.activeCalls > 0;
        log(`Chatbot call finished. Active calls: ${chatbotState.activeCalls}`);
    }
};

// --- Chatbot Tools ---
const tools = [
    {
        type: "function",
        function: {
            name: "create_artifact",
            description: "Generates a new type of artifact with unique properties, element, and description.",
            parameters: {
                type: "object",
                properties: {
                    name: { type: "string", description: "Unique name for the artifact (e.g., 'Sword of Embers', 'Frozen Orb')" },
                    type: { type: "string", enum: ["weapon", "orb", "amulet", "ring"], description: "The type of artifact." },
                    element: { type: "string", description: "The elemental affinity (e.g., 'pyro', 'hydro', 'volt', 'frost', 'terra', 'aether', 'verdant', 'physical', or a newly invented one)." },
                    description: { type: "string", description: "A brief description of the artifact's appearance and lore." },
                    stats: {
                        type: "object",
                        properties: {
                            damage_boost: { type: "number", description: "Percentage damage boost (e.g., 0.1 for 10%)." },
                            health_boost: { type: "number", description: "Flat health boost (e.g., 50)." },
                            elemental_damage: { type: "number", description: "Flat damage boost for its element (e.g., 10)." },
                            attack_speed: { type: "number", description: "Attack speed multiplier (e.g., 1.1 for 10% faster)." }
                        },
                        required: [] // Make stats optional initially
                    },
                    visual_description: { type: "string", description: "Describe its visual appearance (e.g., 'glowing red sword', 'blue orb swirling with water')." }
                },
                required: ["name", "type", "element", "description", "stats", "visual_description"]
            }
        }
    },
    {
        type: "function",
        function: {
            name: "create_mob",
            description: "Generates a new type of mob (monster) with stats, element, behavior, and description.",
            parameters: {
                type: "object",
                properties: {
                    name: { type: "string", description: "Unique name for the mob (e.g., 'Lava Golem', 'Ice Sprite')." },
                    element: { type: "string", description: "The mob's elemental affinity." },
                    description: { type: "string", description: "A brief description of the mob." },
                    base_health: { type: "number", description: "Base health points (e.g., 100)." },
                    base_damage: { type: "number", description: "Base attack damage (e.g., 10)." },
                    attack_speed: { type: "number", description: "Attacks per second (e.g., 0.5)." },
                    movement_speed: { type: "number", description: "Movement speed units per second (e.g., 2)." },
                    xp_reward: { type: "number", description: "Experience points awarded on defeat." },
                    loot_table: { type: "array", items: { type: "string" }, description: "List of artifact template names this mob can drop." },
                    visual_description: { type: "string", description: "Describe its visual appearance (e.g., 'large rocky golem with magma veins', 'small floating blue sprite')." },
                    behavior: { type: "string", enum: ["aggressive", "defensive", "ranged"], description: "Basic combat behavior pattern." } // Simple behavior types
                },
                required: ["name", "element", "description", "base_health", "base_damage", "attack_speed", "movement_speed", "xp_reward", "loot_table", "visual_description", "behavior"]
            }
        }
    },
    {
        type: "function",
        function: {
            name: "create_dungeon",
            description: "Designs a new dungeon instance with a theme, mobs, and a final boss.",
            parameters: {
                type: "object",
                properties: {
                    name: { type: "string", description: "A thematic name for the dungeon (e.g., 'The Molten Core', 'Glacial Caverns')." },
                    theme_description: { type: "string", description: "Describe the dungeon's environment visually and atmospherically." },
                    mob_types: { type: "array", items: { type: "string" }, description: "List of mob template names to populate the dungeon." },
                    mob_count: { type: "number", description: "Approximate number of mobs in the dungeon." },
                    boss_type: { type: "string", description: "The template name of the boss mob for this dungeon." },
                    boss_health_multiplier: { type: "number", description: "Multiplier for the boss's base health (e.g., 5)." },
                    boss_damage_multiplier: { type: "number", description: "Multiplier for the boss's base damage (e.g., 2)." },
                    visual_description: { type: "string", description: "Describe the gate entrance visual (e.g., 'fiery portal', 'icy archway')." }
                },
                required: ["name", "theme_description", "mob_types", "mob_count", "boss_type", "boss_health_multiplier", "boss_damage_multiplier", "visual_description"]
            }
        }
    },
    {
        type: "function",
        function: {
            name: "sense_world",
            description: "Provides the chatbot with a summary of the current game state to inform content generation decisions. Call this when deciding WHAT to generate next.",
            parameters: {
                type: "object",
                properties: {} // No parameters needed, the server provides the data
            }
        }
    },
     {
        type: "function",
        function: {
            name: "create_element",
            description: "Invents a completely new element and defines its interactions with existing elements.",
            parameters: {
                type: "object",
                properties: {
                    name: { type: "string", description: "Unique name for the new element (e.g., 'Aether', 'Void', 'Chrono')." },
                    color_hex: { type: "string", description: "A hex color code for visual representation (e.g., '0x8A2BE2')." },
                    description: { type: "string", description: "Description of the element's nature." },
                    reactions: {
                        type: "object",
                        description: "Define reactions when this element interacts with others. Keys are existing element names (lower case), values are reaction descriptions (e.g., {'pyro': 'Creates 'Plasma Burn', dealing damage over time'}). Describe the effect.",
                        additionalProperties: { type: "string" }
                    }
                },
                required: ["name", "color_hex", "description", "reactions"]
            }
        }
    }
];

// Helper function for consistent ID generation from names
const generateIdFromName = (name) => name.toLowerCase().replace(/[^a-z0-9_\s]/g, '').trim().replace(/\s+/g, '_');

// --- Tool Call Handlers ---
const toolHandlers = {
    create_artifact: (args) => {
        log("Handling tool call: create_artifact", args);
        const id = args.name.toLowerCase().replace(/\s+/g, '_');
        if (knownArtifactTemplates[id]) {
            log(`Artifact template ${id} already exists.`);
            return `Artifact template ${id} already exists.`;
        }
         if (!knownElements[args.element.toLowerCase()]) {
             log(`Cannot create artifact: Unknown element ${args.element} for artifact ${args.name}. Ensure elements are created first.`);
             return `Cannot create artifact: Unknown element ${args.element} for artifact ${args.name}. Ensure elements are created first.`;
            log(`Warning: Unknown element ${args.element} for artifact ${args.name}. Using physical.`);
            args.element = 'physical'; // Default to physical if element unknown
        }
        knownArtifactTemplates[id] = {
            id: id,
            name: args.name,
            type: args.type,
            element: args.element.toLowerCase(),
            description: args.description,
            stats: args.stats || {},
            visual: args.visual_description || 'A standard item.', // Use description for visuals
            color: knownElements[args.element.toLowerCase()]?.color || knownElements.physical.color,
        };
        log(`Created artifact template: ${id}`);
        // Maybe grant one to a random player or add to gacha pool?
        return `Artifact template ${knownArtifactTemplates[id].name} created successfully.`;
    },
    create_mob: (args) => {
        log("Handling tool call: create_mob", args);
        // Use the sanitized ID generation
        const id = generateIdFromName(args.name);//const id = args.name.toLowerCase().replace(/\s+/g, '_');

        if (knownMobTemplates[id]) {
            log(`Mob template ${id} already exists.`);
            return `Mob template ${id} already exists.`;
        }
         if (!knownElements[args.element.toLowerCase()]) {
             log(`Cannot create mob: Unknown element ${args.element} for mob ${args.name}. Ensure elements are created first.`);
             return `Cannot create mob: Unknown element ${args.element} for mob ${args.name}. Ensure elements are created first.`;
            log(`Warning: Unknown element ${args.element} for mob ${args.name}. Using physical.`);
            args.element = 'physical';
        }
        // Validate loot table references existing artifact templates
        // Use sanitized IDs for lookup here too
        const validLoot = (args.loot_table || []).filter(aName => knownArtifactTemplates[generateIdFromName(aName)]);
        let invalidLoot = [];
        for(const aName of args.loot_table)
        {
          const sanitizedID = generateIdFromName(aName);
          if (!knownArtifactTemplates[sanitizedID]) 
          {
            invalidLoot.push({"name":aName,"id":sanitizedID});
          }
        }
        if (validLoot.length < (args.loot_table?.length || 0)) {
             log(`Cannot create mob: Some loot table items ${JSON.stringify(invalidLoot)} for mob ${args.name} do not exist yet. Ensure artifacts are created first.`);
             return `Cannot create mob: Some loot table items ${JSON.stringify(invalidLoot)} for mob ${args.name} do not exist yet. Ensure artifacts are created first.`;
            log(`Warning: Some loot table items for mob ${args.name} do not exist yet.`);
        }

        knownMobTemplates[id] = { // Store using sanitized ID
            id: id,
            name: args.name,
            element: args.element.toLowerCase(),
            description: args.description,
            baseHealth: args.base_health || 50,
            baseDamage: args.base_damage || 5,
            attackSpeed: args.attack_speed || 1, // attacks per second
            moveSpeed: args.movement_speed || 2, // units per second
            xpReward: args.xp_reward || 10,
            lootTable: validLoot.map(aName => generateIdFromName(aName)), // Store sanitized IDs
            visual: args.visual_description || 'A fearsome creature.',
            color: knownElements[args.element.toLowerCase()]?.color || knownElements.physical.color,
            behavior: args.behavior || 'aggressive',
        };
        log(`Created mob template: ${id}`);
        // Maybe spawn one immediately for testing?
        // spawnMob(id);
        return `Mob template ${knownMobTemplates[id].name} created successfully.`;
    },
    create_dungeon: (args) => {
        log("Handling tool call: create_dungeon", args);
        const dungeonId = uuidv4();

        // Validate mob/boss types exist
        // Use sanitized IDs for lookup
        const validMobTypes = args.mob_types.filter(mName => knownMobTemplates[generateIdFromName(mName)]);
        const bossTemplateId = generateIdFromName(args.boss_type);
        const bossTemplate = knownMobTemplates[bossTemplateId];

        if (validMobTypes.length === 0 || !bossTemplate) {
             log(`Cannot create dungeon '${args.name}': Invalid mob types or boss type '${args.boss_type}'. Ensure mobs are created first.`);
             return `Cannot create dungeon '${args.name}'. Invalid mob or boss types specified. Required templates: ${args.mob_types.join(', ')}, ${args.boss_type}`;
        }

        const gatePosition = getRandomPosition(0.5); // Position the gate randomly in the arena
        clampToArena(gatePosition); // Ensure gate is within bounds
        gatePosition.x = Math.random() > 0.5 ? ARENA_SIZE - 1 : -ARENA_SIZE + 1; // Place on left or right edge
        gatePosition.z = (Math.random() - 0.5) * ARENA_SIZE * 1.8; // Random along that edge
        clampToArena(gatePosition); // Clamp Z


        dungeons[dungeonId] = {
            id: dungeonId,
            name: args.name,
            theme: args.theme_description,
            gatePosition: gatePosition,
            gateVisual: args.visual_description || 'A swirling portal.',
            mobs: {}, // Mobs currently inside the dungeon instance
            mobTemplates: validMobTypes.map(mName => generateIdFromName(mName)), // Store sanitized IDs
            targetMobCount: args.mob_count || 10,
            bossTemplateId: bossTemplateId,
            bossId: null, // ID of the spawned boss instance
            bossHealthMultiplier: args.boss_health_multiplier || 5,
            bossDamageMultiplier: args.boss_damage_multiplier || 2,
            isBossDefeated: false,
            closingTime: null, // Timestamp when dungeon starts closing after boss defeat
            playersInside: new Set(), // Keep track of players inside
        };

        log(`Created dungeon ${args.name} (${dungeonId}) at ${JSON.stringify(gatePosition)}. Gate: ${dungeons[dungeonId].gateVisual}`);

        // Spawn initial mobs and the boss for the dungeon instance
        spawnDungeonMobs(dungeonId);

        io.emit('dungeon_created', dungeons[dungeonId]); // Notify clients about the new gate
        return `Dungeon ${args.name} created successfully with ID ${dungeonId}. Gate opened.`;
    },
     sense_world: (args) => {
        log("Handling tool call: sense_world (providing data to chatbot)");
        const playerCount = Object.keys(players).length;
        const mobCount = Object.keys(mobs).length;
        const averageLevel = playerCount > 0
            ? Object.values(players).reduce((sum, p) => sum + p.level, 0) / playerCount
            : 0;
        const activeDungeons = JSON.stringify(Object.keys(dungeons));//.length;
        const knownArtifactCount = JSON.stringify(Object.keys(knownArtifactTemplates));//.length;
        const knownMobCount = JSON.stringify(Object.keys(knownMobTemplates));//.length;

        const worldStateSummary = `
        Current World State:
        - Players Online: ${playerCount}
        - Average Player Level: ${averageLevel.toFixed(1)}
        - Active Mobs: ${mobCount}
        - Active Dungeons: ${activeDungeons}
        - Known Artifact Types: ${knownArtifactCount}
        - Known Mob Types: ${knownMobCount}
        - Known Elements: ${Object.keys(knownElements).join(', ')}
        - Time since last dungeon creation: ${((Date.now() - chatbotState.lastDungeonCreation) / 1000).toFixed(0)} seconds.

        Consider the state: Are players potentially bored (low mobs/dungeons)? Are they stressed (too many mobs)? Is there enough variety (artifact/mob types)? Do they need a new challenge (dungeon)? Is it time to invent a new element?
        Based on this, decide if you should call create_artifact, create_mob, create_dungeon, or create_element. Only make one call. If nothing seems needed, just reply with your assessment.
        `;
        log("World state summary for chatbot:", worldStateSummary);
        return worldStateSummary; // This summary will be included in the *next* message TO the chatbot
    },
     create_element: (args) => {
        log("Handling tool call: create_element", args);
        const elementId = args.name.toLowerCase();
        if (knownElements[elementId]) {
            return `Element ${args.name} already exists.`;
        }
        if (!(args.color_hex || /^0x[0-9A-Fa-f]{6}$/.test(args.color_hex) || /^#[0-9A-Fa-f]{6}$/.test(args.color_hex))) {
             log(`Cannot create element: Invalid color hex ${args.color_hex} for element ${args.name}. use 0x or # format.`);
             return `Cannot create element: Invalid color hex ${args.color_hex} for element ${args.name}. use 0x or # format.`;
            log(`Invalid color hex ${args.color_hex} for element ${args.name}. Using default grey.`);
            args.color_hex = '0xaaaaaa';
        }

        knownElements[elementId] = {
            name: elementId,
            color: parseInt(args.color_hex, 16),
            description: args.description,
        };

        // Add reaction definitions (simplified - store descriptions for now)
        elementReactions[elementId] = {}; // Reactions FROM this element
        for (const targetElement in args.reactions) {
            const reactionDesc = args.reactions[targetElement];
            log(`Defining reaction: ${elementId} attacking ${targetElement} -> ${reactionDesc}`);
            // For now, just log and maybe add a default damage multiplier or status effect placeholder
            // A more complex system would parse the description to create functional effects
            elementReactions[elementId][targetElement.toLowerCase()] = (t, a, e) => {
                log(`Reaction (${elementId} -> ${targetElement}): ${reactionDesc}`);
                // Placeholder: Apply a small multiplier or a generic status based on description keywords?
                 let multiplier = 1.1; // Default bonus for new reaction
                 if (reactionDesc.toLowerCase().includes("damage over time")) {
                     elementReactions._applyStatus(t, { name: `${elementId}-${targetElement}-dot`, dps: 6, interval: 1000 }, 5000);
                 }
                 if (reactionDesc.toLowerCase().includes("immobilize") || reactionDesc.toLowerCase().includes("stun")) {
                      elementReactions._applyStatus(t, { name: `${elementId}-${targetElement}-stun`, immobilize: true }, 2000);
                 }
                 if (reactionDesc.toLowerCase().includes("vulnerable") || reactionDesc.toLowerCase().includes("defense down")) {
                     // Need a way to modify target stats temporarily
                 }
                 return multiplier;
            };
             // Also define the reverse reaction placeholder if the chatbot didn't specify it
             if (!elementReactions[targetElement.toLowerCase()]) {
                 elementReactions[targetElement.toLowerCase()] = {};
             }
             if (!elementReactions[targetElement.toLowerCase()][elementId]) {
                 elementReactions[targetElement.toLowerCase()][elementId] = elementReactions._default;
                  log(`Defining reverse reaction placeholder: ${targetElement} attacking ${elementId}`);
             }
        }

        log(`Created new element: ${elementId}`);
        io.emit('elements_updated', knownElements); // Notify clients of the new element list
        return `New element ${args.name} created successfully with its reactions.`;
    },
};

// --- Chatbot Interaction Logic ---
const triggerChatbotSenseAndAct = async () => {
    if (chatbotState.isBusy) return;
 let failed_to_create_dungeon = true;
 let failed_to_create_dungeon_text = "";
 let failed_to_create_text = "";
 while(failed_to_create_dungeon) 
 {
    log("Triggering chatbot sense and act cycle...");
    const senseResult = toolHandlers.sense_world({}); // Get current world state summary

    const messages = [
        { role: "system", content: "You are an AI game master for an MMORPG. Your goal is to keep the game interesting and challenging by dynamically creating content like artifacts, mobs, dungeons, and even new elements. Use the provided tools to modify the game world. Analyze the world state provided by the 'sense_world' tool response and decide on ONE action (or none if the world seems balanced). Prioritize creating dungeons if players seem bored or have cleared existing ones. Invent new things when variety is low. when creating something be sure that all elements exists, so first create needed elements." },
        { role: "assistant", content: senseResult } // Provide the world state as if the assistant called sense_world
    ];
  if (failed_to_create_dungeon)
  {
    log("failed_to_create_dungeon...");
        if (failed_to_create_dungeon_text) {
          messages.push({ role: "user", content: failed_to_create_dungeon_text })
        }
        if (failed_to_create_text) {
          messages.push({ role: "user", content: failed_to_create_text })
        }
  }

    const toolCalls = await callOllamaAPI(messages, tools);

    if (toolCalls && toolCalls.length > 0) {
        // Process only the first tool call for simplicity as requested
        const call = toolCalls[0];
        if (call.type === "function" && toolHandlers[call.function.name]) {
            try {
                const args = JSON.parse(call.function.arguments);
                const handlerResult = toolHandlers[call.function.name](args);
                log(`Tool call '${call.function.name}' executed. Result: ${handlerResult}`);
                 if (call.function.name === 'create_dungeon') {
  if (handlerResult.includes("Cannot create")) 
  {
    failed_to_create_dungeon_text = "previous your attempt to create dungeon was:\n "+ JSON.stringify(args) + "\n with result: \n" + handlerResult + "\n please call other tools to finish creation of dungeon";
                log(failed_to_create_dungeon_text);
    failed_to_create_dungeon = true;
  } else {
    failed_to_create_dungeon = false;
  }
                    chatbotState.lastDungeonCreation = Date.now(); // Track when a dungeon was made
                 } else {
  if (handlerResult.includes("Cannot create")) 
  {
    failed_to_create_text = "addidtionally your creation attempt was:\n "+ JSON.stringify(args) + "\n with result: \n" + handlerResult + "\n please call other tools to finish creation";
                log(failed_to_create_text);
  } else {
    failed_to_create_text = "";
  }
                 }
                 // We could potentially send the result back to Ollama for a follow-up, but let's keep it simple.
            } catch (e) {
                console.error(`Error parsing arguments or executing tool ${call.function.name}:`, e);
                log("Failed arguments:", call.function.arguments);
            }
        } else {
            log("Received tool call, but no handler found or invalid type:", call);
        }
    } else {
        log("Chatbot decided not to take action or failed to call a tool.");
    }
 }
     chatbotState.lastSenseTime = Date.now();
};

const triggerChatbotIfNeeded = () => {
    const now = Date.now();
    const timeSinceLastSense = now - chatbotState.lastSenseTime;
    const timeSinceLastDungeon = now - chatbotState.lastDungeonCreation;
    const dungeonsExist = Object.keys(dungeons).length > 0;
    const playersExist = Object.keys(players).length > 0;

    // Trigger if enough time passed, or if players exist and there are no dungeons for a while
    if (!chatbotState.isBusy && playersExist && timeSinceLastSense > chatbotState.senseInterval) {
         if (!dungeonsExist && timeSinceLastDungeon > chatbotState.dungeonTriggerInterval / 5) { // Trigger faster if no dungeons
              log("No dungeons active and players online, triggering chatbot sense/act.");
              triggerChatbotSenseAndAct();
         } else if (timeSinceLastDungeon > chatbotState.dungeonTriggerInterval) { // Standard interval
              log("Dungeon creation interval reached, triggering chatbot sense/act.");
              triggerChatbotSenseAndAct();
         } else if (timeSinceLastSense > chatbotState.senseInterval * 2) { // General check if intervals not met but time passed
             log("General sense interval reached, triggering chatbot sense/act.");
             triggerChatbotSenseAndAct();
         }
    } else if (!chatbotState.isBusy && playersExist && Object.keys(knownMobTemplates).length < 2) {
        // Ensure there's at least some content if players are online
        log("Initial content generation check (few mobs/artifacts), triggering chatbot sense/act.");
        triggerChatbotSenseAndAct();
    }
};


// --- Game Logic ---

const calculateLevel = (xp) => {
    // Infinite level scaling - adjust formula as needed
    return Math.floor(Math.sqrt(xp / 100)) + 1;
};

const getPlayerStats = (playerId) => {
    const player = players[playerId];
    if (!player) return { maxHealth: 100, damage: 10, attackSpeed: 1, moveSpeed: 5, element: knownElements.physical };

    let stats = {
        maxHealth: (100 + (player.level * 10)) * HEALTH_AND_ATTACK_MULTIPLIER,
        damage: (10 + (player.level * 2)) * HEALTH_AND_ATTACK_MULTIPLIER,
        attackSpeed: 1, // attacks per second
        moveSpeed: 5 * BOT_SPEED_MULTIPLIER, // units per second
        element: knownElements.physical, // Default element
    };

    const activeArtifactId = player.equippedArtifacts[player.activeArtifactSlot];
    if (activeArtifactId && player.inventory[activeArtifactId]) {
        const artifactTemplate = knownArtifactTemplates[player.inventory[activeArtifactId].templateId];
        if (artifactTemplate) {
            stats.element = knownElements[artifactTemplate.element.toLowerCase()] || knownElements.physical; // Element from active artifact
            if (artifactTemplate.stats) {
                stats.maxHealth += artifactTemplate.stats.health_boost || 0;
                stats.damage *= (1 + (artifactTemplate.stats.damage_boost || 0));
                 stats.damage += artifactTemplate.stats.elemental_damage || 0; // Add flat elemental damage too
                stats.attackSpeed *= artifactTemplate.stats.attack_speed || 1;
            }
        }
    }
     // Apply level bonus after artifact base stats
     stats.maxHealth += (player.level * 15); // Increase health scaling
     stats.damage += (player.level * 3);    // Increase damage scaling


    // Could add more stat calculations from other equipped artifacts later if needed
    // For now, only the active artifact heavily influences combat stats + element

    return stats;
};

const applyDamage = (target, damage, attacker) => {
    if (!target || target.health <= 0) return;

    let finalDamage = damage;
    let reactionMultiplier = 1.0;
    let statusEffects = [];

    const attackerElement = attacker?.stats?.element || knownElements.physical;
    let targetElement = target.element; // Mobs have base element
    if (target.isPlayer) {
       // Players maybe have temporary elemental shields or base resistance? For now, they take element from attacker directly.
       // Or maybe target element is based on their *own* active artifact? Let's assume they are 'neutral' unless affected.
       targetElement = knownElements.physical; // Default player element unless affected by status
    }

    // Check for status effects that define the target's current element (e.g., burning = pyro)
    if (target.statusEffects) {
        for (const effectName in target.statusEffects) {
            const effect = target.statusEffects[effectName];
            if (effect.element && Date.now() < effect.expires) {
                 targetElement = knownElements[effect.element] || targetElement;
                 break; // Simplification: only consider one primary status element
            }
             // Check for Quicken interaction
             if (effect.name === 'quicken' && Date.now() < effect.expires) {
                 const quickenReaction = elementReactions.quicken[attackerElement.name];
                 if (quickenReaction) {
                     reactionMultiplier *= quickenReaction(target, attacker, attackerElement);
                 }
             }
        }
    }


    // Calculate base elemental reaction
    if (attackerElement && targetElement && elementReactions[targetElement.name] && elementReactions[targetElement.name][attackerElement.name]) {
        reactionMultiplier *= elementReactions[targetElement.name][attackerElement.name](target, attacker, attackerElement);
    } else if (attackerElement && elementReactions._default) {
         reactionMultiplier *= elementReactions._default(target, attacker, attackerElement); // Default interaction
    }


    finalDamage *= reactionMultiplier;
    finalDamage = Math.max(1, Math.round(finalDamage)); // Ensure at least 1 damage

    target.health -= finalDamage;
    log(`${attacker?.id || 'Unknown'} dealt ${finalDamage} (${attackerElement?.name}) damage to ${target.id}. Reaction Multiplier: ${reactionMultiplier.toFixed(2)}. Health left: ${target.health}`);

    // Check for death
    if (target.health <= 0) {
        target.health = 0;
        handleDeath(target, attacker);
    }

    // Send damage event for visual feedback?
    io.emit('damage_taken', { targetId: target.id, attackerId: attacker?.id, damage: finalDamage, element: attackerElement.name });
};

const handleDeath = (target, killer) => {
    log(`${target.id} was defeated by ${killer?.id || 'environment'}.`);
    if (target.isPlayer) {
        // Player death: Respawn logic? For now, just reset health and position maybe?
        target.health = target.stats.maxHealth;
        target.position = getRandomPosition(0.5); // Respawn randomly
        target.targetId = null; // Clear target
        io.to(target.id).emit('player_respawn', { position: target.position, health: target.health });
        log(`Player ${target.id} respawned.`);
        // TODO: Lose XP? Drop items?
    } else {
        // Mob death
        if (killer && killer.isPlayer) {
            killer.xp += target.xpReward || 10;
            const oldLevel = killer.level;
            killer.level = calculateLevel(killer.xp);
            if (killer.level > oldLevel) {
                log(`Player ${killer.id} leveled up to ${killer.level}!`);
                killer.stats = getPlayerStats(killer.id); // Recalculate stats on level up
                killer.health = killer.stats.maxHealth; // Full heal on level up
                io.to(killer.id).emit('level_up', { level: killer.level, stats: killer.stats, health: killer.health });
            }
            io.to(killer.id).emit('xp_gain', { xp: killer.xp, level: killer.level });
        }

        // Handle loot drops
        if (target.lootTable && target.lootTable.length > 0) {
            target.lootTable.forEach(templateId => {
                if (knownArtifactTemplates[templateId] && Math.random() < 0.3) { // 30% drop chance per item in table
                    spawnArtifact(templateId, target.position);
                }
            });
        }
         // Boss specific logic
         if (target.isBoss && target.dungeonId) {
             const dungeon = dungeons[target.dungeonId];
             if (dungeon) {
                 dungeon.isBossDefeated = true;
                 dungeon.closingTime = Date.now() + DUNGEON_CLOSE_DELAY_MS;
                 log(`Boss ${target.name} in dungeon ${dungeon.name} defeated! Dungeon closing soon.`);
                 // Drop guaranteed boss loot? Maybe a higher chance or specific items?
                  target.lootTable.forEach(templateId => {
                       if (knownArtifactTemplates[templateId] && Math.random() < 0.8) { // Higher drop chance for boss
                           spawnArtifact(templateId, target.position);
                       }
                   });
                   // Maybe drop a unique boss artifact? Needs chatbot definition
             }
         }


        // Remove mob from game state and dungeon (if applicable)
        const dungeonId = target?.dungeonId;
        delete mobs[target.id];
         if (dungeonId && dungeons[dungeonId] && dungeons[dungeonId].mobs[target.id]) {
              delete dungeons[dungeonId].mobs[target.id];
              log(`Removed mob ${target.id} from dungeon ${dungeonId}`);
              // Check if dungeon needs more mobs? (Handled in dungeon logic)
         }

        io.emit('mob_removed', target.id); // Notify clients
    }
};

const spawnArtifact = (templateId, position) => {
    const template = knownArtifactTemplates[templateId];
    if (!template) {
        log(`Attempted to spawn unknown artifact template ${templateId}`);
        return;
    }
    const artifactId = uuidv4();
    const artifactInstance = {
        id: artifactId,
        templateId: templateId,
        name: template.name,
        visual: template.visual,
        color: template.color,
        element: template.element,
        position: { ...position, y: 0.2 }, // Place slightly above ground
        spawnTime: Date.now(),
    };
    artifacts[artifactId] = artifactInstance;
    log(`Spawned artifact ${template.name} (${artifactId}) at ${JSON.stringify(artifactInstance.position)}`);
    io.emit('artifact_spawned', artifactInstance);
};

const spawnMob = (templateId, position = null, dungeonId = null, isBoss = false, healthMultiplier = 1, damageMultiplier = 1) => {
    const template = knownMobTemplates[templateId];
    if (!template) {
        log(`Attempted to spawn unknown mob template ${templateId}`);
        return null;
    }
    const mobId = uuidv4();
    const spawnPos = position || getRandomPosition(0.5);
    clampToArena(spawnPos); // Ensure mobs spawn within bounds

    const mobInstance = {
        id: mobId,
        templateId: templateId,
        name: template.name,
        visual: template.visual,
        color: template.color,
        element: knownElements[template.element] || knownElements.physical,
        position: spawnPos,
        health: Math.round(template.baseHealth * healthMultiplier * HEALTH_AND_ATTACK_MULTIPLIER),
        maxHealth: Math.round(template.baseHealth * healthMultiplier * HEALTH_AND_ATTACK_MULTIPLIER),
        damage: Math.round(template.baseDamage * damageMultiplier * HEALTH_AND_ATTACK_MULTIPLIER),
        attackSpeed: template.attackSpeed, // attacks per second
        moveSpeed: template.moveSpeed, // units per second
        xpReward: template.xpReward,
        lootTable: template.lootTable || [],
        behavior: template.behavior,
        targetId: null, // Player ID it's targeting
        lastAttackTime: 0,
        isMob: true, // Identifier
        dungeonId: dungeonId, // Track which dungeon it belongs to
        isBoss: isBoss,
        statusEffects: {},
    };
    mobs[mobId] = mobInstance;
    log(`Spawned mob ${template.name} (${mobId}) at ${JSON.stringify(mobInstance.position)}. Health: ${mobInstance.health}, Damage: ${mobInstance.damage}${dungeonId ? ` in Dungeon ${dungeonId}` : ''}${isBoss ? ' [BOSS]' : ''}`);

     // If part of a dungeon, add to dungeon's mob list
     if (dungeonId && dungeons[dungeonId]) {
         dungeons[dungeonId].mobs[mobId] = mobInstance;
         if (isBoss) {
             dungeons[dungeonId].bossId = mobId;
         }
     }

    io.emit('mob_spawned', mobInstance); // Notify clients
    return mobInstance;
};

const spawnDungeonMobs = (dungeonId) => {
     const dungeon = dungeons[dungeonId];
     if (!dungeon) return;

     log(`Spawning mobs for dungeon: ${dungeon.name} (${dungeonId})`);

     // Spawn regular mobs
     const mobsToSpawn = dungeon.targetMobCount - Object.keys(dungeon.mobs).length;
     for (let i = 0; i < mobsToSpawn; i++) {
         if (dungeon.mobTemplates.length > 0) {
             const mobTemplateId = dungeon.mobTemplates[Math.floor(Math.random() * dungeon.mobTemplates.length)];
             // Spawn mobs 'inside' the dungeon - for now, just spawn them near the gate
             const spawnPos = {
                 x: dungeon.gatePosition.x + (Math.random() - 0.5) * 5, // Clustered near gate
                 y: 0.5,
                 z: dungeon.gatePosition.z + (Math.random() - 0.5) * 5,
             };
             // In a real dungeon system, position would be inside the dungeon map
             spawnMob(mobTemplateId, spawnPos, dungeonId);
         }
     }

     // Spawn the boss if not already spawned and not defeated
     if (!dungeon.bossId && !dungeon.isBossDefeated) {
         const bossTemplateId = dungeon.bossTemplateId;
          const bossSpawnPos = {
                 x: dungeon.gatePosition.x + (Math.random() > 0.5 ? 3 : -3), // Slightly further in
                 y: 0.5,
                 z: dungeon.gatePosition.z + (Math.random() > 0.5 ? 3 : -3),
             };
         const bossInstance = spawnMob(
             bossTemplateId,
             bossSpawnPos,
             dungeonId,
             true, // isBoss = true
             dungeon.bossHealthMultiplier,
             dungeon.bossDamageMultiplier
         );
         if (bossInstance) {
             dungeon.bossId = bossInstance.id;
         } else {
             log(`Error: Failed to spawn boss ${bossTemplateId} for dungeon ${dungeonId}`);
         }
     }
 };


const giveArtifactToPlayer = (playerId, templateId) => {
    const player = players[playerId];
    const template = knownArtifactTemplates[templateId];
    if (!player || !template) {
        log(`Cannot give artifact ${templateId} to player ${playerId}: Player or template not found.`);
        return false;
    }

    const inventoryId = uuidv4(); // Unique ID for this specific instance in inventory
    player.inventory[inventoryId] = {
        id: inventoryId,
        templateId: template.id,
        name: template.name,
        element: template.element,
         // You might store rolled stats here if artifacts had variance
    };

    // Auto-equip if slots available? Equip to first empty slot or replace first slot.
    let equipped = false;
    for (let i = 0; i < 4; i++) {
        if (!player.equippedArtifacts[i]) {
            player.equippedArtifacts[i] = inventoryId;
            log(`Auto-equipped ${template.name} to slot ${i} for player ${playerId}`);
             // Set as active if it's the first one equipped
             if (player.equippedArtifacts.filter(Boolean).length === 1) {
                 player.activeArtifactSlot = i;
                 log(`Set ${template.name} as active artifact for ${playerId}`);
             }
            equipped = true;
            break;
        }
    }
     // If no empty slots, maybe notify player instead of overwriting?
     // For simplicity now, we won't overwrite automatically.
     if (!equipped && Object.keys(player.inventory).length <= 4) {
         // If inventory is small (initial items), force equip the first one.
          if (!player.equippedArtifacts[0]) {
                 player.equippedArtifacts[0] = inventoryId;
                 player.activeArtifactSlot = 0;
                 equipped = true;
                 log(`Force-equipped ${template.name} to slot 0 for player ${playerId}`);
          }
     }


    player.stats = getPlayerStats(playerId); // Recalculate stats
    io.to(playerId).emit('inventory_update', {
        inventory: player.inventory,
        equipped: player.equippedArtifacts,
        activeSlot: player.activeArtifactSlot,
        stats: player.stats // Send updated stats
    });
    log(`Gave artifact ${template.name} (${inventoryId}) to player ${playerId}. Equipped: ${equipped}`);
    return true;
};


const performGachaWish = (playerId) => {
     const player = players[playerId];
     if (!player) return;

     const now = Date.now();
     if (now < player.nextGachaTime) {
         log(`Player ${playerId} tried gacha too early.`);
         // Send message to player? For now, just fail silently server-side.
         return;
     }

     player.nextGachaTime = now + GACHA_INTERVAL_MS;
     io.to(playerId).emit('gacha_timer_update', player.nextGachaTime);

     const availableTemplates = Object.keys(knownArtifactTemplates);
     if (availableTemplates.length === 0) {
         log("Gacha wish failed: No artifact templates available.");
         // Maybe trigger chatbot to create one?
         if (!chatbotState.isBusy) {
             log("Triggering chatbot to create an initial artifact due to empty gacha pool.");
              callOllamaAPI(
                  [
                      { role: "system", content: "You are an AI game master. Create a simple starting artifact for players using the create_artifact tool. Make it 'physical' or a common element like 'pyro'." },
                      { role: "user", content: "Players need their first artifact. Create one now." }
                  ],
                  tools.filter(t => t.function.name === 'create_artifact') // Only provide artifact tool
              ).then(toolCalls => {
                 if (toolCalls && toolCalls.length > 0) {
                     const call = toolCalls[0];
                     if (call.type === "function" && toolHandlers[call.function.name]) {
                         try {
                             const args = JSON.parse(call.function.arguments);
                             const handlerResult = toolHandlers[call.function.name](args);
                             log(`Tool call '${call.function.name}' executed. Result: ${handlerResult}`);
                             // Retry gacha AFTER artifact created? Complex timing. Player can just click again.
                         } catch (e) { console.error("Error processing immediate artifact creation:", e); }
                     }
                 }
             });
         }
         return;
     }

     const randomTemplateId = availableTemplates[Math.floor(Math.random() * availableTemplates.length)];
     const success = giveArtifactToPlayer(playerId, randomTemplateId);
     if (success) {
         log(`Player ${playerId} received artifact ${randomTemplateId} from gacha.`);
         io.to(playerId).emit('show_message', `You received: ${knownArtifactTemplates[randomTemplateId].name}!`);
     } else {
         log(`Failed to give gacha artifact ${randomTemplateId} to player ${playerId}.`);
         // Reset timer if failed? Or let it stay? Let's reset it so they can try again sooner.
         player.nextGachaTime = now;
          io.to(playerId).emit('gacha_timer_update', player.nextGachaTime);
          io.to(playerId).emit('show_message', `Gacha failed. No artifact templates available?`);

     }
 };


// --- Game Loop ---
const gameLoop = () => {
    const now = Date.now();
    deltaTime = (now - (lastTickTime || now)) / 1000; // Time since last tick in seconds //const
    lastTickTime = now;

    // --- Update Logic ---

    // Player movement & actions (process queued actions if any)
    Object.values(players).forEach(player => {
        // Movement handled by direct position updates from client for simplicity,
        // but server should validate/clamp positions.
        clampToArena(player.position);

        // Update stats in case equipped items changed out of combat (handled via socket events)
        // player.stats = getPlayerStats(player.id); // This might be too frequent, do on change instead.

         // Apply status effects (DoT, immobilization, etc.)
         if (player.statusEffects) {
             let immobilized = false;
             Object.keys(player.statusEffects).forEach(effectName => {
                 const effect = player.statusEffects[effectName];
                 if (now > effect.expires) {
                     delete player.statusEffects[effectName];
                     log(`Status ${effectName} expired on player ${player.id}`);
                 } else {
                      // Apply DoT
                     if (effect.dps && effect.interval) {
                         const timeSinceApplied = now - effect.applied;
                         const ticksPassed = Math.floor(timeSinceApplied / effect.interval);
                         const lastTickTime = effect.lastTickTime || effect.applied; // When was damage last applied?
                         if(now - lastTickTime >= effect.interval) {
                            const damagePerTick = (effect.dps * effect.interval) / 1000;
                            applyDamage(player, damagePerTick, { id: `status_${effectName}` }); // Damage source is the status
                            effect.lastTickTime = now; // Record time damage applied
                            log(`Status ${effectName} dealt ${damagePerTick} damage to player ${player.id}`);
                         }
                     }
                     // Check for immobilization
                     if (effect.immobilize) {
                         immobilized = true;
                         // Client needs to know it's immobilized to potentially stop sending move inputs or show visual
                         // We could send a status update event here if needed.
                     }
                 }
             });
              // If immobilized, maybe prevent movement updates? Complex interaction with client input.
              // Server could ignore movement updates while immobilized.
         }

        // Attack cooldown
        if (player.targetId && now > player.lastAttackTime + (1000 / player.stats.attackSpeed)) {
             const target = players[player.targetId] || mobs[player.targetId];
             if (target && target.health > 0) {
                  const distance = calculateDistance(player.position, target.position);
                  if (distance <= PLAYER_REACH) {
                     log(`Player ${player.id} attacking target ${player.targetId}`);
                     applyDamage(target, player.stats.damage, player);
                     player.lastAttackTime = now;
                     io.emit('player_attack', { playerId: player.id, targetId: player.targetId }); // For animations/effects
                  } else {
                      // Target out of range, clear target? Or let player move closer?
                      // player.targetId = null; // Simple: clear if out of range
                  }
             } else {
                 player.targetId = null; // Target died or disconnected
             }
        }
    });

    // Mob AI & actions
    Object.values(mobs).forEach(mob => {
         // Apply status effects (DoT, immobilization, etc.)
         if (mob.statusEffects) {
             let immobilized = false;
              Object.keys(mob.statusEffects).forEach(effectName => {
                 const effect = mob.statusEffects[effectName];
                 if (now > effect.expires) {
                     delete mob.statusEffects[effectName];
                      log(`Status ${effectName} expired on mob ${mob.id}`);
                 } else {
                     if (effect.dps && effect.interval) {
                          const lastTickTime = effect.lastTickTime || effect.applied;
                          if (now - lastTickTime >= effect.interval) {
                             const damagePerTick = (effect.dps * effect.interval) / 1000;
                             applyDamage(mob, damagePerTick, { id: `status_${effectName}`, stats: { element: knownElements[effect.element] || knownElements.physical } }); // Pass element if status implies it
                             effect.lastTickTime = now;
                              log(`Status ${effectName} dealt ${damagePerTick} damage to mob ${mob.id}`);
                          }
                     }
                     if (effect.immobilize) {
                         immobilized = true;
                     }
                 }
             });
             if (immobilized) {
                  mob.targetId = null; // Stop chasing if frozen etc.
                  // Don't process movement or attacks below if immobilized
                  return; // Skip rest of AI for this tick
             }
         }


        // Simple AI: Find nearest player and move towards/attack
        let nearestPlayer = null;
        let minDistance = Infinity;

        Object.values(players).forEach(player => {
            // Mobs only attack players outside 'safe zones' (none defined yet)
            // Mobs inside dungeons should only target players inside that dungeon? (Add logic later)
            if (player.health > 0) {
                 // If mob is in a dungeon, only target players also in that dungeon (or near gate?)
                 let canTarget = true;
                 // if (mob.dungeonId && dungeons[mob.dungeonId] && !dungeons[mob.dungeonId].playersInside.has(player.id)) {
                 //    // Basic check: if dungeon exists and player isn't marked as 'inside', don't target.
                 //    // Needs a way to mark players as inside (e.g., when they interact with the gate)
                 //    // For now, let mobs near gates target anyone nearby.
                 //    const gateDist = calculateDistance(player.position, dungeons[mob.dungeonId].gatePosition);
                 //    if(gateDist > 10) { // Only target players close to the dungeon gate if mob is part of dungeon
                 //      canTarget = false;
                 //    }
                 // }

                if(canTarget) {
                    const distance = calculateDistance(mob.position, player.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPlayer = player;
                    }
                }
            }
        });

        if (nearestPlayer) {
            mob.targetId = nearestPlayer.id;
            const target = players[mob.targetId]; // Get fresh ref

            if (target && target.health > 0) {
                 const distance = minDistance; // Already calculated

                 // Attack if in range
                 if (distance <= MOB_REACH) {
                      if (now > mob.lastAttackTime + (1000 / mob.attackSpeed)) {
                         log(`Mob ${mob.id} attacking player ${target.id}`);
                         // Mobs use their base element for attacks
                         applyDamage(target, mob.damage, { id: mob.id, stats: { element: mob.element } });
                         mob.lastAttackTime = now;
                         io.emit('mob_attack', { mobId: mob.id, targetId: target.id });
                      }
                 }
                 // Move towards target if not in range (and not attacking)
                 else if(distance > MOB_REACH) {
                     const moveSpeed = mob.moveSpeed * deltaTime;
                     const dx = target.position.x - mob.position.x;
                     const dz = target.position.z - mob.position.z;
                     const angle = Math.atan2(dz, dx);

                     mob.position.x += Math.cos(angle) * moveSpeed;
                     mob.position.z += Math.sin(angle) * moveSpeed;
                     clampToArena(mob.position);
                 }
            } else {
                 mob.targetId = null; // Target died or is invalid
            }

        } else {
            mob.targetId = null; // No players nearby or alive
            // Idle behavior? Wander? Stand still? For now, stand still.
        }
    });

    // Artifact despawn check
    Object.keys(artifacts).forEach(id => {
        if (now > artifacts[id].spawnTime + ARTIFACT_DESPAWN_TIME_MS) {
            log(`Despawning artifact ${artifacts[id].name} (${id})`);
            delete artifacts[id];
            io.emit('artifact_removed', id);
        }
    });

     // Dungeon closing check
     Object.keys(dungeons).forEach(id => {
         const dungeon = dungeons[id];
         if (dungeon.closingTime && now > dungeon.closingTime) {
             log(`Closing dungeon ${dungeon.name} (${id}).`);
             // Remove remaining mobs associated with the dungeon
             Object.keys(mobs).filter(mobId => mobs[mobId]).forEach(mobId => {
                 if (mobs[mobId].dungeonId === id) {
                     delete mobs[mobId];
                     io.emit('mob_removed', mobId);
                 }
             });
             // Remove dungeon itself
             delete dungeons[id];
             io.emit('dungeon_removed', id);
         }
     });


    // --- State Synchronization ---
    // Send relevant parts of the state to clients
    const gameState = {
        players: Object.values(players).map(p => ({ // Send limited player data
            id: p.id,
            position: p.position,
            lookDirection: p.lookDirection,
            health: p.health,
            maxHealth: p.stats?.maxHealth || 100, // Include max health
            level: p.level,
            // Don't send inventory/full stats constantly
        })),
        mobs: Object.values(mobs).map(m => ({ // Send limited mob data
            id: m.id,
            templateId: m.templateId, // For client-side visuals?
            name: m.name,
            visual: m.visual,
            color: m.color,
            position: m.position,
            health: m.health,
            maxHealth: m.maxHealth, // Include max health
            isBoss: m.isBoss,
             // Send status effects? Maybe just names/visual cues needed?
            statuses: m.statusEffects ? Object.keys(m.statusEffects) : [],
        })),
         // Only send artifacts on the ground, not full templates
        artifacts: Object.values(artifacts).map(a => ({
            id: a.id,
            name: a.name,
            position: a.position,
            visual: a.visual, // Description for client visual hint
            color: a.color, // Color hint
            element: a.element, // Element hint
        })),
         // Send dungeon gate info
         dungeons: Object.values(dungeons).map(d => ({
             id: d.id,
             name: d.name,
             gatePosition: d.gatePosition,
             gateVisual: d.gateVisual,
             isClosing: !!d.closingTime && d.closingTime > now, // Boolean flag if closing
         })),
    };
    io.emit('game_state', gameState);

    // Trigger Chatbot periodically or based on game conditions
    triggerChatbotIfNeeded();
};

let lastTickTime = null;

// --- Socket.IO Handlers ---
io.on('connection', (socket) => {
    log(`Player connected: ${socket.id}`);

    // Create player object
    players[socket.id] = {
        id: socket.id,
        position: getRandomPosition(0.5),
        lookDirection: { x: 0, y: 0, z: -1 }, // Facing forward initially
        health: 100,
        xp: 0,
        level: 1,
        inventory: {}, // { inventoryId: { templateId: '...', name: '...' } }
        equippedArtifacts: [null, null, null, null], // Array of inventoryIds or null
        activeArtifactSlot: 0, // Index 0-3 of the currently active artifact
        targetId: null, // ID of the player/mob being targeted
        lastAttackTime: 0,
        nextGachaTime: Date.now(), // Can wish immediately on connect
        isPlayer: true, // Identifier
        stats: null, // Will be calculated
        statusEffects: {},
    };
    players[socket.id].stats = getPlayerStats(socket.id); // Calculate initial stats
     players[socket.id].health = players[socket.id].stats.maxHealth; // Start with full health


    // Send initial state to the new player
    socket.emit('init_state', {
        playerId: socket.id,
        initialState: {
            players: Object.values(players).map(p => ({ id: p.id, position: p.position, lookDirection: p.lookDirection, health: p.health, maxHealth: p.stats.maxHealth, level: p.level })),
            mobs: Object.values(mobs).map(m => ({ id: m.id, templateId: m.templateId, name: m.name, visual: m.visual, color: m.color, position: m.position, health: m.health, maxHealth: m.maxHealth, isBoss: m.isBoss, statuses: m.statusEffects ? Object.keys(m.statusEffects) : [] })),
            artifacts: Object.values(artifacts),
            dungeons: Object.values(dungeons).map(d => ({ id: d.id, name: d.name, gatePosition: d.gatePosition, gateVisual: d.gateVisual, isClosing: !!d.closingTime && d.closingTime > Date.now()})),
            knownElements: knownElements,
        },
        playerData: { // Send specific data for this player
             inventory: players[socket.id].inventory,
             equipped: players[socket.id].equippedArtifacts,
             activeSlot: players[socket.id].activeArtifactSlot,
             stats: players[socket.id].stats,
             xp: players[socket.id].xp,
             level: players[socket.id].level,
             nextGachaTime: players[socket.id].nextGachaTime,
        },
        version: VERSION,
         debug: DEBUG, // Let client know if debug is enabled
    });

    // Broadcast new player connection to others
    socket.broadcast.emit('player_joined', {
        id: socket.id,
        position: players[socket.id].position,
        lookDirection: players[socket.id].lookDirection,
        health: players[socket.id].health,
        maxHealth: players[socket.id].stats.maxHealth,
        level: players[socket.id].level,
    });

    // Handle player input
    socket.on('player_move', (data) => {
        const player = players[socket.id];
        if (player && data.position && data.lookDirection) {
             // Basic validation/sanitization could happen here
             // Check for immobilization status
             let immobilized = false;
             if (player.statusEffects) {
                 Object.values(player.statusEffects).forEach(effect => {
                     if (effect.immobilize && Date.now() < effect.expires) {
                         immobilized = true;
                     }
                 });
             }

             if (!immobilized) {
                 player.position.x = data.position.x;
                 player.position.y = data.position.y; // Allow vertical movement? Keep it simple for now.
                 player.position.z = data.position.z;
                 player.lookDirection.x = data.lookDirection.x;
                 player.lookDirection.y = data.lookDirection.y;
                 player.lookDirection.z = data.lookDirection.z;

                 clampToArena(player.position); // Ensure player stays within bounds
             } else {
                 // Send back corrected position if immobilized?
                 socket.emit('force_position', player.position);
             }
        }
    });

    socket.on('player_attack', (data) => {
        const player = players[socket.id];
        if (player && player.health > 0) {
            // Client signals intent to attack, server finds nearest valid target in front?
            // Or client sends target ID? Let's use client target ID for simplicity.
            const targetId = data?.targetId; // Client might suggest a target
            let actualTarget = null;

            if (targetId && (players[targetId] || mobs[targetId])) {
                 // Target specified by client
                 actualTarget = players[targetId] || mobs[targetId];
                 const distance = calculateDistance(player.position, actualTarget.position);
                 if (distance > PLAYER_REACH || actualTarget.health <= 0) {
                     actualTarget = null; // Target invalid or too far
                 }
            } else {
                 // Auto-target nearest mob/player in front if no target specified
                 let closestTarget = null;
                 let minAngle = 0.5; // Target within ~30 degrees cone
                 let minDist = PLAYER_REACH;

                 const checkTarget = (potentialTarget) => {
                      if (!potentialTarget || potentialTarget.id === player.id || potentialTarget.health <= 0) return;

                      const distance = calculateDistance(player.position, potentialTarget.position);
                      if (distance <= minDist) {
                          const dx = potentialTarget.position.x - player.position.x;
                          const dz = potentialTarget.position.z - player.position.z;
                          const targetVec = new THREE.Vector3(dx, 0, dz).normalize();
                          const lookVec = new THREE.Vector3(player.lookDirection.x, 0, player.lookDirection.z).normalize();
                          const angle = targetVec.angleTo(lookVec);

                          if (angle < minAngle) {
                               closestTarget = potentialTarget;
                               minDist = distance; // Prefer closer targets within the cone
                               minAngle = angle; // Tighten angle slightly if a target is found
                          }
                      }
                 };

                 Object.values(mobs).forEach(checkTarget);
                 Object.values(players).forEach(checkTarget); // Allow targeting players (PvP)
                 actualTarget = closestTarget;
            }


            if (actualTarget) {
                player.targetId = actualTarget.id;
                // Attack execution is handled in the game loop based on player.targetId and cooldown
                log(`Player ${socket.id} initiated attack, target set to ${player.targetId}`);
            } else {
                 log(`Player ${socket.id} attack failed, no valid target found.`);
                 player.targetId = null; // Clear target if attack fails to find one
            }
        }
    });

    socket.on('player_pickup_artifact', () => {
         const player = players[socket.id];
         if (!player) return;

         let pickedUp = false;
         Object.keys(artifacts).forEach(id => {
             const artifact = artifacts[id];
             const distance = calculateDistance(player.position, artifact.position);
             if (distance < 1.5) { // Pickup range
                  if (Object.keys(player.inventory).length < 50) { // Arbitrary inventory limit
                     const success = giveArtifactToPlayer(player.id, artifact.templateId);
                     if(success) {
                         log(`Player ${player.id} picked up artifact ${artifact.name} (${id})`);
                         delete artifacts[id];
                         io.emit('artifact_removed', id);
                         pickedUp = true;
                         // Stop checking after one pickup per request
                         return; // Exit forEach early
                     } else {
                         log(`Failed to give artifact ${artifact.name} to player ${player.id}`);
                         io.to(player.id).emit('show_message', `Failed to pick up ${artifact.name}.`);
                     }
                  } else {
                      log(`Player ${player.id} inventory full, cannot pick up ${artifact.name}`);
                      io.to(player.id).emit('show_message', `Inventory full!`);
                      // Stop checking, inventory is full
                      return;
                  }
             }
         });
          if (!pickedUp) {
              log(`Player ${player.id} tried pickup, no artifacts in range or inventory full.`);
          }
     });

    socket.on('player_equip_artifact', (data) => {
        const player = players[socket.id];
        const { inventoryId, slotIndex } = data; // Expecting { inventoryId: '...', slotIndex: 0-3 }

        if (!player || slotIndex < 0 || slotIndex > 3 || !player.inventory[inventoryId]) {
            log(`Invalid equip request from ${socket.id}:`, data);
            return;
        }

         // Check if player is in combat? For now allow equip anytime.
         // In final version: disallow during combat.

         // Unequip item currently in target slot (if any) back to inventory conceptually
         // (it's already in inventory, just remove from equipped slot)
         const previouslyEquippedId = player.equippedArtifacts[slotIndex];

         // Place the new item in the slot
         player.equippedArtifacts[slotIndex] = inventoryId;

         // If the currently active item was replaced, potentially change active slot?
         // Or just let the player choose active separately? Let's require separate 'activate' action.
         // If the equipped item WAS the active one, ensure active slot still points correctly.
         if (player.activeArtifactSlot === slotIndex) {
             // The active item was just changed, stats need update.
             player.stats = getPlayerStats(player.id);
             // Make sure health doesn't exceed new max health if it changed.
             player.health = Math.min(player.health, player.stats.maxHealth);

         } else if (previouslyEquippedId && player.inventory[previouslyEquippedId]) {
             // An item was unequipped from a non-active slot. Stats might change if it provided passive bonuses (not implemented yet).
             // For now, only active slot affects stats, so no change needed unless active slot is involved.
         }


         log(`Player ${socket.id} equipped artifact ${player.inventory[inventoryId].name} (${inventoryId}) to slot ${slotIndex}`);

         io.to(socket.id).emit('inventory_update', {
             inventory: player.inventory,
             equipped: player.equippedArtifacts,
             activeSlot: player.activeArtifactSlot,
             stats: player.stats, // Send updated stats if they changed
             health: player.health // Send updated health
         });
    });

     socket.on('player_set_active_artifact', (data) => {
          const player = players[socket.id];
          const { slotIndex } = data; // Expecting { slotIndex: 0-3 }

          if (!player || slotIndex < 0 || slotIndex > 3) {
              log(`Invalid set active slot request from ${socket.id}:`, data);
              return;
          }

          const inventoryIdInSlot = player.equippedArtifacts[slotIndex];
          if (!inventoryIdInSlot || !player.inventory[inventoryIdInSlot]) {
               log(`Player ${socket.id} tried to activate empty or invalid slot ${slotIndex}`);
               // Maybe clear active slot if invalid? Or ignore? Ignore for now.
               return;
          }


          if (player.activeArtifactSlot !== slotIndex) {
              player.activeArtifactSlot = slotIndex;
              player.stats = getPlayerStats(player.id); // Recalculate stats based on new active artifact
              player.health = Math.min(player.health, player.stats.maxHealth); // Adjust health to new max if needed
              log(`Player ${socket.id} set active artifact slot to ${slotIndex} (${player.inventory[inventoryIdInSlot].name})`);

              io.to(socket.id).emit('inventory_update', {
                  inventory: player.inventory,
                  equipped: player.equippedArtifacts,
                  activeSlot: player.activeArtifactSlot,
                  stats: player.stats, // Send updated stats
                  health: player.health // Send updated health
              });
          }
     });


     socket.on('player_gacha_wish', () => {
         performGachaWish(socket.id);
     });

     // Request version (for client checking)
     socket.on('request_version', () => {
         socket.emit('version_info', { version: VERSION });
     });


    socket.on('disconnect', () => {
        log(`Player disconnected: ${socket.id}`);
        io.emit('player_left', socket.id); // Notify clients
        // Remove player from dungeon player lists if they disconnect
         Object.values(dungeons).forEach(dungeon => {
             dungeon.playersInside.delete(socket.id);
         });
        delete players[socket.id];
    });
});

// --- Debug Mode Setup ---
const initializeDebugContent = () => {
    if (!DEBUG) return;
    log("Initializing Debug Mode Content...");
    let createdSomething = false; // Flag to track if we added anything new

    // 1. Pre-create Elements (if not existing) - chatbot should do this normally
    //    (Example - assuming chatbot hasn't run yet)
     if (!knownElements['plasma']) {
        toolHandlers.create_element({
            name: "Plasma", color_hex: "0xFF00FF", description: "Superheated ionized gas.",
            reactions: { hydro: "Vaporizes violently (High Dmg)", cryo: "Thermal Shock (Stun chance)"}
        });
        createdSomething = true;
     }


    // 2. Pre-create Artifact Templates FIRST using the tool handler
    if (Object.keys(knownArtifactTemplates).length < 2) {
        toolHandlers.create_artifact({
            name: "Debug Sword", type: "weapon", element: "physical", description: "A basic sword for testing.",
            stats: { damage_boost: 0.05, elemental_damage: 5 }, visual_description: "Simple grey sword"
        });
        toolHandlers.create_artifact({
            name: "Debug Orb", type: "orb", element: "pyro", description: "A basic orb for testing.",
            stats: { health_boost: 20, elemental_damage: 8, attack_speed: 1.1 }, visual_description: "Small red orb"
        });
         toolHandlers.create_artifact({
            name: "Cryo Amulet", type: "amulet", element: "cryo", description: "Chilling to the touch.",
            stats: { health_boost: 30, damage_boost: 0.05 }, visual_description: "Pale blue amulet"
        });
        createdSomething = true;
    }

    // 3. Pre-create Mob Templates NEXT using the tool handler
    if (Object.keys(knownMobTemplates).length < 2) {
        toolHandlers.create_mob({
             name: "Debug Slime", element: "hydro", description: "A wobbly slime.", base_health: 50, base_damage: 5, attack_speed: 0.8, movement_speed: 1.5, xp_reward: 5,
             loot_table: [], visual_description: "Blue translucent blob", behavior: "aggressive"
        });
         toolHandlers.create_mob({
             name: "Debug Goblin", element: "physical", description: "A weak goblin.", base_health: 80, base_damage: 8, attack_speed: 1, movement_speed: 2.5, xp_reward: 10,
            // Ensure loot table uses names/IDs created above (lowercase_with_underscores)
            loot_table: ["debug_sword"], visual_description: "Small green humanoid with club", behavior: "aggressive"
        });
         toolHandlers.create_mob({
            name: "Flame Imp", element: "pyro", description: "A mischievous fire spirit.", base_health: 60, base_damage: 12, attack_speed: 1.2, movement_speed: 3, xp_reward: 15,
            loot_table: ["debug_orb"], visual_description: "Small winged creature made of fire", behavior: "ranged"
        });
         toolHandlers.create_mob({
             name: "Stone Golem Boss", element: "geo", description: "A large, slow guardian.", base_health: 300, base_damage: 25, attack_speed: 0.5, movement_speed: 1, xp_reward: 100, // Removed parentheses from name for simplicity
             loot_table: ["debug_sword", "cryo_amulet"], visual_description: "Hulking figure of rock", behavior: "aggressive" // Can drop multiple types
          });
         createdSomething = true;
    }

    // 4. Pre-create a Dungeon LAST using the tool handler (if mobs exist)
    if (Object.keys(dungeons).length === 0 && Object.keys(knownMobTemplates).length >= 3) {
         toolHandlers.create_dungeon({
             name: "Debug Den",
             theme_description: "A simple cave.",
             mob_types: ["Debug Goblin", "Flame Imp"], // Reference by original name
             mob_count: 5,
             boss_type: "Stone Golem Boss", // Reference boss by its (now sanitized) name
             boss_health_multiplier: 2,
             boss_damage_multiplier: 1.5,
             visual_description: "Mossy cave entrance"
         });
    }


    // 5. Spawn some initial mobs if none exist
    if (Object.keys(mobs).length === 0 && Object.keys(knownMobTemplates).length >= 2) {
        spawnMob("debug_slime");
        spawnMob("debug_goblin");
        createdSomething = true; // Technically already covered by mob template creation check
    }

     // 6. Spawn Player Bots (Simulated Players)
     const desiredBots = DESIRED_BOTS;
     const currentBots = Object.values(players).filter(p => p.isBot).length;
     for (let i = 0; i < desiredBots - currentBots; i++) {
         spawnPlayerBot(`Bot_${i + 1}`);
     }

    if(createdSomething) {
        log("Debug content initialization finished (created new items).");
    } else {
        log("Debug content initialization finished (content already existed).");
    }
};

// --- Player Bot Logic ---
const playerBotIntervals = {};

const spawnPlayerBot = (botId) => {
    if (players[botId]) return; // Don't spawn if already exists

    log(`Spawning Player Bot: ${botId}`);
    const bot = {
        id: botId,
        isBot: true, // Flag it as a bot
        position: getRandomPosition(0.5),
        lookDirection: { x: 0, y: 0, z: -1 },
        health: 100, // Initial health
        xp: 0,
        level: 1,
        inventory: {},
        equippedArtifacts: [null, null, null, null],
        activeArtifactSlot: 0,
        targetId: null,
        lastAttackTime: 0,
        nextGachaTime: Date.now(),
        isPlayer: true,
        stats: null, // Calculated below
        statusEffects: {},
        // Bot-specific state
        state: "idle", // idle, seeking_dungeon, fighting, collecting, seeking_target
        lastStateChange: Date.now(),
        currentDungeonTarget: null, // ID of dungeon it's heading towards/in
    };
    players[botId] = bot;
    bot.stats = getPlayerStats(botId); // Calculate initial stats
    bot.health = bot.stats.maxHealth;

     // Give bot initial artifacts via gacha
     setTimeout(() => performGachaWish(botId), 1000); // Delay slightly
     setTimeout(() => performGachaWish(botId), 2000); // Get a second one maybe

    // Simulate connection event for other clients
    io.emit('player_joined', {
        id: bot.id,
        position: bot.position,
        lookDirection: bot.lookDirection,
        health: bot.health,
        maxHealth: bot.stats.maxHealth,
        level: bot.level,
         isBot: true, // Let clients know it's a bot if they care
    });

    // Start the bot's AI loop
    playerBotIntervals[botId] = setInterval(() => playerBotAI(botId), 1000 + Math.random() * 500); // Stagger updates slightly
};

const removePlayerBot = (botId) => {
     if (!players[botId] || !players[botId].isBot) return;
     log(`Removing Player Bot: ${botId}`);
     clearInterval(playerBotIntervals[botId]);
     delete playerBotIntervals[botId];
     delete players[botId];
     io.emit('player_left', botId);
 };

const playerBotAI = (botId) => {
    const bot = players[botId];
    if (!bot || bot.health <= 0) {
        // Bot is dead or removed, clean up interval
         log(`Bot ${botId} is inactive or dead, stopping AI.`);
         removePlayerBot(botId); // Ensure cleanup
        return;
    }

     const now = Date.now();

     // --- Bot Actions ---

     // 1. Gacha Wish if available
     if (now >= bot.nextGachaTime) {
         performGachaWish(botId); // Uses the regular player function
     }

     // 2. Pickup nearby artifacts
     let pickedUpSomething = false;
     Object.values(artifacts).forEach(artifact => {
         if (calculateDistance(bot.position, artifact.position) < 1.5) {
             // Simulate pickup request
             // We need to call the same logic as the socket handler
              const inventoryId = uuidv4();
              if (Object.keys(bot.inventory).length < 50) {
                  bot.inventory[inventoryId] = { id: inventoryId, templateId: artifact.templateId, name: artifact.name, element: artifact.element };
                   log(`Bot ${botId} picked up ${artifact.name}`);
                   delete artifacts[artifact.id];
                   io.emit('artifact_removed', artifact.id); // Notify clients
                   pickedUpSomething = true;
                    // Auto-equip logic for bot (simple version)
                    let equipped = false;
                    for(let i=0; i<4; i++) {
                        if(!bot.equippedArtifacts[i]) {
                            bot.equippedArtifacts[i] = inventoryId;
                             if(bot.equippedArtifacts.filter(Boolean).length === 1) bot.activeArtifactSlot = i; // Activate first equip
                            equipped = true;
                            break;
                        }
                    }
                    if(equipped) {
                        bot.stats = getPlayerStats(botId); // Update stats
                         log(`Bot ${botId} auto-equipped ${artifact.name}`);
                    }
              } else {
                   log(`Bot ${botId} inventory full.`);
              }
         }
     });
     if(pickedUpSomething) {
         // Re-evaluate state after picking up
         bot.state = 'idle';
     }


     // 3. State Machine Logic
     const setState = (newState) => {
         if (bot.state !== newState) {
             log(`Bot ${botId} changing state from ${bot.state} to ${newState}`);
             bot.state = newState;
             bot.lastStateChange = now;
             bot.targetId = null; // Clear mob target on most state changes
             bot.currentDungeonTarget = null; // Clear dungeon target
         }
     };

     // Timeout long states
     if (now - bot.lastStateChange > 30000) { // 30 seconds timeout
         log(`Bot ${botId} timed out in state ${bot.state}, resetting to idle.`);
         setState('idle');
     }

     // Core AI Decision Making
     switch (bot.state) {
         case 'idle':
             // Decide what to do next: Find dungeon? Find mobs?
             if (Object.keys(dungeons).length > 0) {
                 setState('seeking_dungeon'); // Prioritize dungeons if available
             } else {
                 setState('seeking_target'); // Otherwise hunt anything
             }
             break;

         case 'seeking_dungeon':
             // Find nearest dungeon gate
             let nearestDungeon = null;
             let minDistDungeon = Infinity;
             Object.values(dungeons).forEach(d => {
                 if (!d.isClosing) { // Don't go to closing dungeons
                      const dist = calculateDistance(bot.position, d.gatePosition);
                      if (dist < minDistDungeon) {
                          minDistDungeon = dist;
                          nearestDungeon = d;
                      }
                 }
             });

             if (nearestDungeon) {
                 bot.currentDungeonTarget = nearestDungeon.id; // Remember which dungeon
                 const targetPos = nearestDungeon.gatePosition;
                 const distance = calculateDistance(bot.position, targetPos);

                 if (distance < 2.0) { // Close enough to the gate
                     log(`Bot ${botId} reached dungeon gate ${nearestDungeon.name}.`);
                     // Simulate entering? For now, just start fighting mobs nearby (dungeon mobs spawn near gate)
                     setState('fighting');
                 } else {
                     // Move towards gate
                     moveBotTowards(bot, targetPos, deltaTime); // Need deltaTime from main loop? Use fixed value for bot.
                 }
             } else {
                 // No dungeons found or all are closing
                 setState('seeking_target'); // Fallback to hunting mobs/players
             }
             break;

         case 'seeking_target': // Renamed from seeking_mob
             // Find nearest valid target (mob or non-bot player)
              let nearestTarget = null;
              let minDist = Infinity;

              // Check mobs first
               Object.values(mobs).forEach(mob => {
                   if (mob.health > 0) {
                       const dist = calculateDistance(bot.position, mob.position);
                       if (dist < minDist) {
                           minDist = dist;
                           nearestTarget = mob;
                       }
                  }
              });

               // Check players (non-bot)
               if(!nearestTarget) Object.values(players).forEach(player => {
                  if (player.health > 0 && player.id !== botId) { // Don't target self //  && !player.isBot or other bots
                       const dist = calculateDistance(bot.position, player.position);
                       if (dist < minDist) {
                           minDist = dist;
                           nearestTarget = player;
                       }
                  }
              });

              if(nearestTarget) {
                   setState('fighting');
                  log(`Bot ${botId} found target ${nearestTarget.id} (Type: ${nearestTarget.isPlayer ? 'Player' : 'Mob'}) at distance ${minDist.toFixed(1)}`);
                  bot.targetId = nearestTarget.id;
              } else {
                   // No mobs found, wander or stay idle? Stay idle.
                   setState('idle');
              }
             break;

         case 'fighting':
              // Check current target
              let currentTarget = players[bot.targetId] || mobs[bot.targetId]; // Bots can PvP too!
              if (!currentTarget || currentTarget.health <= 0) {
                  log(`Bot ${botId} target ${bot.targetId} defeated or gone.`);
                  bot.targetId = null;
                   // Target gone, look for loot nearby before finding new target
                   setState('collecting');
                  // setState('seeking_mob'); // Find a new target immediately? Loot first is better.
                  break;
              }

              const distance = calculateDistance(bot.position, currentTarget.position);
              if (distance <= PLAYER_REACH) {
                  // Attack if cooldown ready
                   if (now > bot.lastAttackTime + (1000 / bot.stats.attackSpeed)) {
                        log(`Bot ${botId} attacking target ${bot.targetId}`);
                        // Use the same damage function as players
                        applyDamage(currentTarget, bot.stats.damage, bot);
                        bot.lastAttackTime = now;
                        io.emit('player_attack', { playerId: bot.id, targetId: bot.targetId });
                   }
              } else if (distance < 20) { // Chase range
                  // Move towards target
                   moveBotTowards(bot, currentTarget.position, 1.0); // Fixed delta for simplicity
              } else {
                   // Target too far, give up?
                   log(`Bot ${botId} lost target ${bot.targetId} (too far).`);
                   bot.targetId = null; // Clear target
                   setState('seeking_target'); // Look for a new one
              }
             break;

          case 'collecting':
              // Briefly look for nearby artifacts on the ground
              let foundLoot = false;
              Object.values(artifacts).forEach(artifact => {
                  const dist = calculateDistance(bot.position, artifact.position);
                  if (dist < 5.0) { // Search radius
                       moveBotTowards(bot, artifact.position, 1.0); // Move towards loot
                       foundLoot = true;
                       return; // Move towards the first found loot item
                  }
              });

              if (!foundLoot || now - bot.lastStateChange > 5000) { // If no loot nearby or collecting for too long
                   log(`Bot ${botId} finished collecting or found no loot.`);
                   // Decide next action based on dungeon status
                   const dungeon = dungeons[bot.currentDungeonTarget];
                   if (dungeon && !dungeon.isBossDefeated) {
                       setState('fighting'); // Go back to fighting in the dungeon
                   } else if (dungeon && dungeon.isBossDefeated) {
                        log(`Bot ${botId} leaving defeated dungeon ${dungeon.name}`);
                        setState('idle'); // Dungeon cleared, go idle (will seek new dungeon or mobs)
                   } else {
                        setState('seeking_target'); // No active dungeon context, hunt generic targets
                   }
              }
             break;
     }

};

const moveBotTowards = (bot, targetPosition, deltaTime) => {
     if (!bot || !targetPosition) return;
     const moveSpeed = (bot.stats?.moveSpeed || 3) * deltaTime; // Use bot stats if available
     const dx = targetPosition.x - bot.position.x;
     const dz = targetPosition.z - bot.position.z;
     const distance = Math.sqrt(dx*dx + dz*dz);

     if (distance < 0.1) return; // Already close enough

     const angle = Math.atan2(dz, dx);
     const moveDistance = Math.min(moveSpeed, distance); // Don't overshoot

     bot.position.x += Math.cos(angle) * moveDistance;
     bot.position.z += Math.sin(angle) * moveDistance;
     bot.lookDirection = { x: Math.cos(angle), y: 0, z: Math.sin(angle) }; // Look where it's going
     clampToArena(bot.position);
 };


// --- Start Server ---
server.listen(PORT, HOSTNAME, () => {
    log(`Server running at http://${HOSTNAME}:${PORT}/`);
    log(`Debug mode: ${DEBUG}`);
    log(`Ollama API URL: ${OLLAMA_API_URL}`);
    log(`Ollama Model: ${OLLAMA_MODEL}`);
    initializeDebugContent(); // Setup debug stuff if enabled
    setInterval(gameLoop, 1000 / TICK_RATE); // Start the game loop
});

// Need THREE for server-side angle calculations in bot AI, even if not rendering
// This feels a bit messy, might refactor bot look direction differently later.
// For now, import it here just for Vector3.angleTo
import * as THREE from 'three';
